package com.exoteric.sharedactor.interactors.user

import com.exoteric.pypnft.cached.User_Entity
import com.exoteric.sharedactor.datasource.cached.models.SnftrUserEntity
import com.exoteric.sharedactor.datasource.dtos.ClockUserDto
import com.exoteric.sharedactor.domain.data.DataState
import com.exoteric.sharedactor.domain.util.SnftrFlow
import com.exoteric.sharedactor.domain.util.snftrFlow
import com.exoteric.sharedactor.interactors.flowers.SnftrUserFlower
import com.exoteric.snftrdblib.cached.SnftrDatabase
import com.exoteric.snftrsearchlibr.getId
import kotlinx.coroutines.flow.FlowCollector
import kotlinx.coroutines.flow.flow

class SearchSnftrUser(private val snftrDatabase: SnftrDatabase): SnftrUserFlower {

    override fun executeUserSearch(user: SnftrUserEntity):
            SnftrFlow<DataState<List<ClockUserDto>>> =  flow {
        try {
            val queries = snftrDatabase.snftrUsersQueries
            emit(DataState.loading())
            val cachedUserFromDb = queries
                .searchUsersByUid(uid = user.uid)
                .executeAsOneOrNull()
            if (cachedUserFromDb == null) {
                queries.insertUser(
                    id = getId(),
                    uid = user.uid,
                    name = user.name,
                    username = user.username,
                    profilePic = user.profilePic,
                    backgroundPic = user.backgroundPic,
                    email = user.email,
                    favsTime = user.favsTime,
                    cAttsTime = user.cAttsTime,
                    profilesBlob = user.profilesBlob,
                    temperature = user.temperature,
                    pressure = user.pressure,
                    scoresBlob = user.scoresBlob
                )
                println("$TAG insertNewUserIntoCache(): none existing for {user.uid}")
            } else {
                queries.updateUserForExternalDetails(
                    // these are the details to be updated when
                    // loading an external user's profile
                    favsTime = user.favsTime,
                    name = user.name,
                    handle = user.username,
                    scoresBlob = user.scoresBlob,
                    profilePic = user.profilePic,
                    backgroundPic = user.backgroundPic,
                    profilesBlob = user.profilesBlob,
                    // for this user
                    user.uid
                )
                println("$TAG updateExistingUserDetails for {user.uid}")
            }
            // query the cache
            val cachedUser = queries.searchUsersByUid(uid = user.uid).executeAsOneOrNull()
            println("$TAG cacheResult: user uid -> {cachedUser?.uid}")
            // map here since user_entity is generated by SQLDelight
            val list = arrayListOf<ClockUserDto>()
            if (cachedUser != null) {
                list.add(
                    ClockUserDto(
                        id = cachedUser.id.toInt(),
                        uid = cachedUser.uid,
                        name = cachedUser.name,
                        email = cachedUser.email,
                        username = cachedUser.username,
                        profilePic = cachedUser.profilePic,
                        backgroundPic = cachedUser.backgroundPic,
                        favsTime = cachedUser.favsTime,
                        cAttsTime = user.cAttsTime,
                        profilesBlob = cachedUser.profilesBlob,
                        temperature = cachedUser.temperature,
                        pressure = cachedUser.pressure,
                        scoresBlob = cachedUser.scoresBlob
                    )
                )
            }
            println("$TAG Success! executeUserSearch(): cachedUser?.uid")
            // emit List<SnftrUserDto> from cache
            emit(DataState.success(list))
        } catch (e: Exception) {
            emit(DataState.error<List<ClockUserDto>>(e.message ?: "Unknown Error - message null"))
        }
    }.snftrFlow()

    override fun executeUserRestoredSearch(users: MutableList<SnftrUserEntity>?,
                                           currentUid: String):
            SnftrFlow<DataState<List<ClockUserDto>>> =  flow {
        try {
            val queries = snftrDatabase.snftrUsersQueries
            emit(DataState.loading())
            val allCachedUsers = queries
                .selectAll()
                .executeAsList()

            val filteredUsers =
                users?.distinct()?.filter { fp ->
                    fp.uid !in allCachedUsers.map { it.uid } && fp.uid != currentUid
                }

            println("${TAG} executeUserRestoredSearch(): existing: ${allCachedUsers.size} " +
                    "--- adding: ${filteredUsers?.size}")
            if (filteredUsers != null) {
                for (user in filteredUsers) {
                    queries.insertUser(
                        id = getId(),
                        uid = user.uid,
                        name = user.name,
                        username = user.username,
                        profilePic = user.profilePic,
                        backgroundPic = user.backgroundPic,
                        email = user.email,
                        favsTime = user.favsTime,
                        cAttsTime = user.cAttsTime,
                        profilesBlob = user.profilesBlob,
                        temperature = user.temperature,
                        pressure = user.pressure,
                        scoresBlob = user.scoresBlob
                    )
                    println("$TAG insertNewUserIntoCache(): none existing for {user.uid}")
                }
            }
            val currentUser = getCachedUser(uid = currentUid)
            val profilesBlobFollowing = parseProfilesBlobFollowing(currentUser?.profilesBlob)
            if(profilesBlobFollowing.isNullOrEmpty()) {
                return@flow
            }
            val following = profilesBlobFollowing.map { item -> item.uid }
            emit(DataState.loading())
            val allFollowing = queries
                .getFollowingUsers(following)
                .executeAsList()
            emitAllFollowingForCurrentUser(allFollowing, currentUser)
        } catch (e: Exception) {
            emit(DataState.error<List<ClockUserDto>>(e.message ?: "Unknown Error - message null"))
        }
    }.snftrFlow()

    /**
     * Return all cached users for initial search results set.
     */
    fun executeAllUserRestoredSearch(currentUid: String):
            SnftrFlow<DataState<List<ClockUserDto>>> =  flow {
        try {
            val queries = snftrDatabase.snftrUsersQueries
            emit(DataState.loading())
            val allCachedUsers = queries
                .selectAll()
                .executeAsList()
            val filteredUsers =
                allCachedUsers.distinct().filter { fp -> fp.uid != currentUid }
            println("$TAG executeAllUserRestoredSearch(): existing: ${allCachedUsers.size} " +
                    "--- adding: ${filteredUsers.size}")
            val list = arrayListOf<ClockUserDto>()
            for (user in filteredUsers) {
                list.add(
                    ClockUserDto(
                        id = user.id.toInt(),
                        uid = user.uid,
                        name = user.name,
                        email = user.email,
                        username = user.username,
                        profilePic = user.profilePic,
                        backgroundPic = user.backgroundPic,
                        favsTime = user.favsTime,
                        cAttsTime = user.cAttsTime,
                        profilesBlob = user.profilesBlob,
                        // temperature is no longer used, it's all in UserDefaults for iOS
                        // so using the available field in the UserDto for this one scenario...
                        // ahem, so not great.  but using it for the ordering of the
                        // following users.  The whole thing should be ported to firestore.
                        // TODO: port to firestore.  For now all this to store as string in rtdb.
                        temperature = user.temperature,
                        pressure = user.pressure,
                        scoresBlob = user.scoresBlob
                    )
                )
            }
            emit(DataState.success(list))
        } catch (e: Exception) {
            emit(DataState.error<List<ClockUserDto>>(e.message ?: "Unknown Error - message null"))
        }
    }.snftrFlow()

    fun checkFollowingInDb(currentUid: String): Boolean {
        val queries = snftrDatabase.snftrUsersQueries
        val currentUser = getCachedUser(uid = currentUid)
        val profilesBlobFollowing = parseProfilesBlobFollowing(currentUser?.profilesBlob)
        if(profilesBlobFollowing.isNullOrEmpty()) {
            return false
        }
        val following = profilesBlobFollowing.map { item -> item.uid }
        val allFollowing = queries
            .getFollowingUsers(following)
            .executeAsList()
        if(allFollowing.isNotEmpty()) {
            return true
        }
        return false
    }

    private suspend fun FlowCollector<DataState<List<ClockUserDto>>>.emitAllFollowingForCurrentUser(
        allFollowing: List<User_Entity>,
        currentUser: ClockUserDto?) {
        if (allFollowing.isNotEmpty()) {
            val list = arrayListOf<ClockUserDto>()
            for (user in allFollowing) {
                list.add(
                    ClockUserDto(
                        id = user.id.toInt(),
                        uid = user.uid,
                        name = user.name,
                        email = user.email,
                        username = user.username,
                        profilePic = user.profilePic,
                        backgroundPic = user.backgroundPic,
                        favsTime = user.favsTime,
                        cAttsTime = user.cAttsTime,
                        profilesBlob = user.profilesBlob,
                        // temperature is no longer used, it's all in UserDefaults for iOS
                        // so using the available field in the UserDto for this one scenario...
                        // ahem, so not great.  but using it for the ordering of the
                        // following users.  The whole thing should be ported to firestore.
                        // TODO: port to firestore.  For now all this to store as string in rtdb.
                        temperature = getTimeForUID(
                            jsonString = currentUser?.profilesBlob,
                            user.uid
                        ),
                        pressure = user.pressure,
                        scoresBlob = user.scoresBlob
                    )
                )
            }
            emit(DataState.success(list))
        } else {
            emit(DataState.empty("user_not_following"))
        }
    }


    override fun executeUserFollowingSearch(uid: String):
            SnftrFlow<DataState<List<ClockUserDto>>> =  flow {
        try {
            val currentUser = getCachedUser(uid = uid)
            val profilesBlobFollowing = parseProfilesBlobFollowing(currentUser?.profilesBlob)
            if(profilesBlobFollowing.isNullOrEmpty()) {
                return@flow
            }
            val following = profilesBlobFollowing.map { item -> item.uid }
            val queries = snftrDatabase.snftrUsersQueries
            emit(DataState.loading())

            val allFollowing = queries
                .getFollowingUsers(following)
                .executeAsList()
//                println("PROFILESBLOB -> $following and $allFollowing")

                emitAllFollowingForCurrentUser(allFollowing, currentUser)
        } catch (e: Exception) {
            emit(DataState.error<List<ClockUserDto>>(e.message ?: "Unknown Error - message null"))
        }
    }.snftrFlow()

    /**
     * Get a cached user via uid.  Primarily used (exclusively?) for current logged in user.
     */
    fun getCachedUser(uid: String): ClockUserDto? {
//        println("$TAG getCachedUser(): $uid")
        val query = snftrDatabase.snftrUsersQueries
        val user = query.searchUsersByUid(uid = uid).executeAsOneOrNull()
        return if (user != null) {
//            println("$TAG gotCachedUser(): $uid")
            ClockUserDto(
                id = user.id.toInt(),
                uid = user.uid,
                name = user.name,
                username = user.username,
                profilePic = user.profilePic,
                backgroundPic = user.backgroundPic,
                favsTime = user.favsTime,
                cAttsTime = user.cAttsTime,
                email = user.email,
                profilesBlob = user.profilesBlob,
                temperature = user.temperature,
                pressure = user.pressure,
                scoresBlob = user.scoresBlob
            )
        } else null
    }


    /**
     * used for quickly checking if user currently has any following items
     * in profilesBlob.
     */
    fun checkCachedUserHasFollowing(uid: String): Boolean {
        val user = getCachedUser(uid)
        val profilesBlobFollowing = parseProfilesBlobFollowing(user?.profilesBlob)
        return !profilesBlobFollowing.isNullOrEmpty()
    }

    /**
     * used for quickly checking if user currently has any following items
     * in profilesBlob.
     */
    fun checkCachedUserHasBlocked(uid: String): Boolean {
        val user = getCachedUser(uid)
        val profilesBlobBlocked = parseProfilesBlobBlocked(user?.profilesBlob)
        return !profilesBlobBlocked.isNullOrEmpty()
    }

    /**
     * Updates the profilesBlob (from profile sheet in iOS).
     * Called when the user adds or removes either a followed or blocked profile.
     */
    fun updateProfilesBlob(blob: String,
                           uid: String,
                           completion: (result: Boolean) -> Unit) {
        val queries = snftrDatabase.snftrUsersQueries
        queries.updateProfilesBlobForUser(blob, uid)
        val user = queries.searchUsersByUid(uid).executeAsOneOrNull()
        if (user != null) {
            val updatedBlob = user.profilesBlob
            println("$TAG updateProfilesBlob() -> updatedBlob!")
            completion((updatedBlob.isNotEmpty()))
        } else {
            println("$TAG updateProfilesBlob(): update failed!")
            completion(false)
        }
    }

    fun updateCachedUserForBackgroundPic(blob: String,
                                         uid: String,
                                         completion: (result: Boolean) -> Unit) {
        val queries = snftrDatabase.snftrUsersQueries
        queries.updateBackgroundPicBlobForUser(blob, uid)
        val user = queries.searchUsersByUid(uid = uid).executeAsOneOrNull()
        if (user != null) {
            val updatedBlob = user.profilePic
            val updated = updatedBlob.isNotEmpty() && updatedBlob == blob
            if(updated) {
                println("$TAG updateCachedUserForBackgroundPic() -> updatedBlob: $updated")
                completion(updated)
                return
            }
        }

        println("$TAG updateCachedUserForBackgroundPic(): update failed!")
        completion(false)
    }

    fun updateCachedUserForProPic(blob: String,
                                  uid: String,
                                  completion: (result: Boolean) -> Unit) {
        val queries = snftrDatabase.snftrUsersQueries
        queries.updateProPicBlobForUser(blob, uid)
        val user = queries.searchUsersByUid(uid).executeAsOneOrNull()
        if (user != null) {
            val updatedBlob = user.profilePic
            val updated = updatedBlob.isNotEmpty() && updatedBlob == blob
            if(updated) {
                println("$TAG updateCachedUserForProPic() -> updatedBlob: $updated")
                completion(updated)
                return
            }
        }

        println("$TAG updateCachedUserForProPic(): update failed!")
        completion(false)
    }

    /**
     * Updates the user name from logged-in user profile tab.
     * Called from settings tab inside profile view.
     */
    fun updateCachedUserForName(name: String,
                                uid: String,
                                completion: (result: Boolean) -> Unit) {
        val queries = snftrDatabase.snftrUsersQueries
        queries.updateNameForUser(name, uid)
        val user = queries.searchUsersByUid(uid).executeAsOneOrNull()
        if (user != null) {
            val updatedName = user.name
            println("$TAG updateCachedUserForName(name: $name) -> updatedName: $updatedName")
            completion((updatedName.isNotEmpty()))
        } else {
            println("$TAG updateCachedUserForName($name): update failed!")
            completion(false)
        }
    }

    /**
     * Updates the handle/username from logged-in user profile tab.
     * Called from settings tab inside profile view.
     */
    fun updateCachedUserForHandle(handle: String,
                                  uid: String,
                                  completion: (result: Boolean) -> Unit) {
        val queries = snftrDatabase.snftrUsersQueries
        queries.updateHandleForUser(handle, uid)
        val user = queries.searchUsersByUid(uid).executeAsOneOrNull()
        if (user != null) {
            val updatedName = user.username
            println("$TAG updateCachedUserForHandle(handle: $handle) -> updatedName: $updatedName")
            completion((updatedName.isNotEmpty()))
        } else {
            println("$TAG updateCachedUserForHandle($handle): update failed!")
            completion(false)
        }
    }


    fun checkUsersNotInDb(following: List<String>): List<String> {
        val queries = snftrDatabase.snftrUsersQueries
        val allFollowing = queries
            .getFollowingUsers(following)
            .executeAsList()
        // only return the list of uid's from users that are not in the db
        return following.filter{ str -> str !in allFollowing.map { usr -> usr.uid } }
    }

    companion object {
        const val TAG = "SearchSnftrUser"
    }
}