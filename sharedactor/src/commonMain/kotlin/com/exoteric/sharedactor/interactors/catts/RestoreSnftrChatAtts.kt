package com.exoteric.sharedactor.interactors.catts

import com.exoteric.sharedactor.datasource.dtos.ClockChatAttsDto
import com.exoteric.sharedactor.domain.data.DataState
import com.exoteric.sharedactor.domain.util.SnftrFlow
import com.exoteric.sharedactor.domain.util.snftrFlow
import com.exoteric.sharedactor.interactors.flowers.CachedChatAttsFlower
import com.exoteric.snftrdblib.cached.SnftrDatabase
import com.exoteric.snftrsearchlibr.ITEMS_PER_PG_FVRTS
import kotlinx.coroutines.flow.flow

class RestoreSnftrChatAtts(private val snftrDatabase: SnftrDatabase): CachedChatAttsFlower {
    @Throws(Exception::class)
    override fun fetchCachedChatAttsFromDb(uid: String,
                                           currentSnftrUserUid: String?,
                                           page: Int):
            SnftrFlow<DataState<List<ClockChatAttsDto>>> = flow {
        try {
            emit(DataState.loading())
//            if (!Platform().isAndroid()) delay(500)
            // query the cache
            val queries = snftrDatabase.clockChatAttsHistoryQueries
            val cacheResult = queries.restoreAllChatAttsForPageByUid(
                posterUid = uid,
                offset = ((page - 1) * ITEMS_PER_PG_FVRTS).toLong(),
                limit = ITEMS_PER_PG_FVRTS.toLong())
                .executeAsList()
            println("$TAG --> fetchCachedChatAttsFromDb: " + cacheResult.size)
            // emit List<SnftrChatAttsDto> from cache
            // Must manually map this since chatAttHist_Entity object is generated by SQL Delight
            val list: ArrayList<ClockChatAttsDto> = ArrayList()
            for(entity in cacheResult) {
                list.add(
                    ClockChatAttsDto(
                        id = entity.id.toInt(),
                        chatUid = entity.chatUid, // documentID in firebase
                        threadUid = entity.threadUid,
                        originatorBlob = entity.originatorBlob,
                        posterUid = entity.posterUid,
                        mediaBlob = entity.mediaBlob,
                        meta = entity.meta,
                        // dependency for ternary logic in grid anims
                        randomSeed = entity.random_seed.toInt(),
                        thymestamp = entity.thymeStamp,
                        page = 0
                    )
                )
            }
            emit(DataState.success(list))
        } catch (e: Exception) { emit(
            DataState.error<List<ClockChatAttsDto>>(
            e.message?: "RestorePosters: Unknown Error")) }
    }.snftrFlow()

    fun newestCachedTimestamp(uid: String): Long {
        val newest = snftrDatabase.clockChatAttsHistoryQueries
            .getNewest(posterUid = uid)
            .executeAsOneOrNull()?.thymeStamp ?: 0
        println("$TAG: newestCachedTimestamp(uid): $newest")
        return newest
    }

    fun oldestCachedTimestamp(uid: String): Long {
        val oldest = snftrDatabase.clockChatAttsHistoryQueries
            .getOldest(posterUid = uid)
            .executeAsOneOrNull()?.thymeStamp ?: 0
        println("$TAG: oldestCachedTimestamp(uid): $oldest")
        return oldest
    }

    /**
     * how many items are needed in order to fill up a page:
     *
     * if there are 82 items in the cache, then there are 38 needed to
     * fill up a new page if ITEMS_PER_PG_FVRTS == 60
     *
     * @return number of items to add to a new page to == ITEMS_PER_PG_FVRTS
     */
    fun numberOfItemsToFetchForNewPage(uid: String): Int {
        val howMany = ITEMS_PER_PG_FVRTS - (getItemCount(uid = uid) % ITEMS_PER_PG_FVRTS)
        println("$TAG: numberOfItemsToFetchForNewPage(uid: uid): $howMany")
        return howMany
    }

    /**
     * @returns true if:
     * rows in the db >= ITEMS_PER_PG_FVRTS: enough to fill an entire new page
     */
    fun hasCachedForPage(uid: String?, page: Int): Boolean {
        if (uid == null)  return false
        val itemsInCache = getItemCount(uid = uid)
        val itemsInPagesThusFar = ((page - 1) * ITEMS_PER_PG_FVRTS)
        val itemsRemaining = itemsInCache - itemsInPagesThusFar
        // enough to fill a whole new page?
        val goToNextPageWithCache = itemsRemaining >= ITEMS_PER_PG_FVRTS
        println("$TAG: hasCached(uuid: uid, pg: $page): "  +
                "\n $itemsInPagesThusFar items in pages thus far " +
                "\n $itemsRemaining remaining items " +
                "\n $itemsInCache items in total: goWithCache -> $goToNextPageWithCache")
        return goToNextPageWithCache
    }

    fun totalPagesInCache(uid: String): Int {
        return countNumberOfPages(
            numberOfObjects = getItemCount(uid = uid),
            pageSize = ITEMS_PER_PG_FVRTS
        )
    }

    private fun countNumberOfPages(numberOfObjects: Int, pageSize: Int): Int {
        return (numberOfObjects) / pageSize +
                if (numberOfObjects % pageSize == 0
                    || numberOfObjects < pageSize) 0 else 1
    }

    fun getItemCount(uid: String): Int {
        return snftrDatabase.clockChatAttsHistoryQueries
            .selectCountAllForUserid(posterUid = uid)
            .executeAsOneOrNull()?.toInt() ?: -1
    }

    private fun mostRecentCAttsTime(uid: String): Long {
        val queries = snftrDatabase.snftrUsersQueries
        val latestLocalTime = (queries
            .searchUsersByUid(uid = uid)
            .executeAsOneOrNull()?.cAttsTime ?: 1) / 1000
        println("$TAG: mostRecentCAttsTime(): $latestLocalTime")
        return latestLocalTime
    }

    fun fetchOverCache(uid: String): Boolean {
        val latestServerTime = mostRecentCAttsTime(uid = uid)
        val latestLocalTime = snftrDatabase.clockChatAttsHistoryQueries
            .getNewest(posterUid = uid)
            .executeAsOneOrNull()
            ?.thymeStamp ?: 1
        val fetchOverCache =
            (latestServerTime > latestLocalTime) || (latestLocalTime == 1L)
        println("$TAG: fetchOverCache(server: $latestServerTime " +
                "local: $latestLocalTime) -> $fetchOverCache")
        return fetchOverCache
    }

    fun setCurrentPgNumber(page: Int, caller: String) {
        val queries = snftrDatabase.snftrSettingsQueries
        val mostRecentPg = queries
            .getSettingByKey(key = MOST_RECENT_PG_CATTS + caller)
            .executeAsOneOrNull()
        if (mostRecentPg == null) {
            println("$TAG setCurrentPgNumber():" +
                    " mostRecentPg == null, current: $page")
            queries.insertSettings(
                category = CAT_PG_CATTS + caller,
                key = MOST_RECENT_PG_CATTS + caller,
                value_ = page.toString(),
                thymestamp = 0
            )
        } else if (mostRecentPg.value_ != page.toString()){
            println("$TAG setCurrentPgNumber():" +
                    " stale: ${mostRecentPg.value_}, current: $page")
            queries.updateSettings(
                key = MOST_RECENT_PG_CATTS + caller,
                value_ = page.toString())
        }
    }

    fun mostRecentPgNumber(caller: String): Int? {
        val queries = snftrDatabase.snftrSettingsQueries
        val mostRecentPg = queries
            .getSettingByKey(key = MOST_RECENT_PG_CATTS + caller)
            .executeAsOneOrNull()
        println("$TAG pageNumber(): ${mostRecentPg?.value_ ?: 1}")
        return mostRecentPg?.value_?.toInt()
    }


    companion object {
        const val TAG = "RestoreSnftrChatAtts"
        private const val MOST_RECENT_PG_CATTS = "most_recent_pg_catts"
        const val CAT_PG_CATTS = "category_page_catts"
    }
}