package com.exoteric.sharedactor.interactors.favs

import com.exoteric.sharedactor.datasource.cached.models.FavsEntity
import com.exoteric.sharedactor.datasource.dtos.FavsDto
import com.exoteric.sharedactor.domain.data.DataState
import com.exoteric.sharedactor.domain.util.SnftrFlow
import com.exoteric.sharedactor.domain.util.snftrFlow
import com.exoteric.sharedactor.interactors.flowers.SnftrFavsFlower
import com.exoteric.sharedactor.interactors.search.RestoreSnftrs
import com.exoteric.snftrdblib.cached.SnftrDatabase
import com.exoteric.snftrsearchlibr.ITEMS_PER_PG_FVRTS
import com.exoteric.snftrsearchlibr.getId
import kotlinx.coroutines.delay
import kotlinx.coroutines.flow.flow

class SearchSnftrFavorites(private val snftrDatabase: SnftrDatabase) : SnftrFavsFlower {
    override fun executeFavsSearch(favs: MutableList<FavsEntity>?,
                                   uid: String,
                                   page: Int,
                                   caller: String,
                                   isNewSearch: Boolean): SnftrFlow<DataState<List<FavsDto>>> = flow {
        try {
            emit(DataState.loading())
            // delete the stored page value for the given caller on new search, resetting to page 1
            if(isNewSearch) {
                snftrDatabase.snftrSettingsQueries.deleteAllSettingsByTab(category = RestoreSnftrs.CAT_PG_SEARCH + caller)
            }
            // only delay for iOS for pagination,
            // it causes problems on Android,
            // but it allows for proper paging UX in iOS
            delay(500)
            val queries = snftrDatabase.snftrFavoritesQueries
            // filter out any duplicate urls before putting into cache
            val allCachedFvrts = queries.selectAllForUserId(userid = uid).executeAsList()
            // if the incoming server timestamp for the equivalent local item
            // is larger/newer than the local timestamp, update it so
            // future calls to fetchOverCache() will keep checking the
            // network unnecessarily.
            val userQ = snftrDatabase.snftrUsersQueries
            val newestIncoming = (userQ
                .searchUsersByUid(uid = uid)
                .executeAsOneOrNull()?.favsTime ?: -1) / 1000
            if(newestIncoming > 0) {
                // update its local copy if valid
                val query = snftrDatabase.snftrFavoritesQueries
                val latestLocal = query
                    .getNewest(userid = uid)
                    .executeAsOneOrNull()
                if (latestLocal != null) {
                    query.updateNewest(
                        userid = latestLocal.userid,
                        timestamp = newestIncoming,
                        uuid = latestLocal.uuid
                    )
                }
            }
            // 1. check the db for any rows where urlThumb == source_url_thumb
            // 2. filter out any duplicates
            val filteredFavs =
                favs?.distinct()?.filter { fp -> fp.urlThumb !in allCachedFvrts.map { it.source_url_thumb } }
            println("$TAG insertFavsIntoCache(): existing: ${allCachedFvrts.size} " +
                    "--- adding: ${filteredFavs?.size}")
            if (filteredFavs != null) {
                for (entity in filteredFavs) {
                    queries.insertFavorite(
                        id = getId(),
                        uuid = entity.uuid,
                        cmmtUuid = entity.uid,
                        userid = entity.userId,
                        provider = entity.provider,
                        title = entity.title,
                        source_url_detail = entity.urlDetail,
                        source_url_thumb = entity.urlThumb,
                        source_url_owner = entity.urlOwner,
                        creator = entity.creator,
                        creatorProfilePic = entity.creatorProfilePic,
                        originator = entity.originator,
                        // dependency for ternary logic in grid anims
                        random_seed = (1..3201).random().toLong(),
                        thymeStamp = entity.thymeStamp
                    )
                }
            }
            val cacheResult = queries
                .restoreAllFvrtsForPageByUid(
                    userid = uid,
                    offset = ((page - 1) * ITEMS_PER_PG_FVRTS).toLong(),
                    limit = ITEMS_PER_PG_FVRTS.toLong(),
                    // TODO this needs to dynamically switch
                    //  b/w ITEMS_PER_PG_FVRTS and only what was added ??
//                        limit = (filteredFavs?.size ?: 0).toLong()
                ).executeAsList()
            println("$TAG cacheResult: ${cacheResult.size}")
            // map here since favorite_Entity is generated by SQLDelight
            val list = arrayListOf<FavsDto>()
            for (entity in cacheResult) {
                list.add(
                    FavsDto(
                        id = entity.id.toInt(),
                        uid = entity.uuid,
                        cmmtUuid = entity.cmmtUuid,
                        title = entity.title,
                        creator = entity.creator,
                        creatorProfilePic = entity.creatorProfilePic,
                        provider = entity.provider,
                        sourceUrlDetail = entity.source_url_detail,
                        sourceUrlThumb = entity.source_url_thumb,
                        sourceUrlOwner = entity.source_url_owner,
                        posterUid = entity.userid,
                        randomSeed = entity.random_seed.toInt(),
                        thymestamp = entity.thymeStamp,
                        page = 0
                    )
                )
            }
            println("$TAG Success! executeFavsSearch(): ${list.size}")
            // emit List<SnftrFavsDto> from cache
            emit(DataState.success(list))

        } catch (e: Exception) {
            emit(DataState.error<List<FavsDto>>(e.message ?: "$TAG Unknown Error - message null"))
        }
    }.snftrFlow()

    fun addSnftrFavSingle(entity: FavsEntity,
                          myCallback: (added: Boolean) -> Unit) {
        val query = snftrDatabase.snftrFavoritesQueries
        if (query.getFavoriteByUuid(entity.uuid).executeAsOneOrNull() == null) {
            query.insertFavorite(
                id = getId(),
                uuid = entity.uuid,
                cmmtUuid = entity.uid,
                userid = entity.userId,
                provider = entity.provider,
                title = entity.title,
                source_url_detail = entity.urlDetail,
                source_url_thumb = entity.urlThumb,
                source_url_owner = entity.urlOwner,
                creator = entity.creator,
                creatorProfilePic = entity.creatorProfilePic,
                originator = entity.originator,
                // dependency for ternary logic in grid anims
                random_seed = (1..3201).random().toLong(),
                thymeStamp = entity.thymeStamp
            )
            val check = query.getFavoriteByUuid(uuid = entity.uuid).executeAsOneOrNull()
            myCallback(check?.uuid == entity.uuid)
        }
    }

    companion object {
        const val TAG = "SearchSnftrFavs"
    }
}