package com.exoteric.sharedactor.interactors.purchases

import com.exoteric.sharedactor.datasource.dtos.SnftrIDPDto
import com.exoteric.sharedactor.domain.data.DataState
import com.exoteric.sharedactor.domain.util.SnftrFlow
import com.exoteric.sharedactor.domain.util.snftrFlow
import com.exoteric.sharedactor.interactors.flowers.SnftrIDPurchasesCacheFlower
import com.exoteric.snftrdblib.cached.SnftrDatabase
import kotlinx.coroutines.flow.flow


class RestorePurchases(private val snftrDatabase: SnftrDatabase) : SnftrIDPurchasesCacheFlower {
    @Throws(Exception::class)
    override fun fetchCachedIDAWNPurchases(hashName: String):
            SnftrFlow<DataState<List<SnftrIDPDto>>> = flow {
        try {
            emit(DataState.loading())
            val queries = snftrDatabase.clockPurchasesQueries
            val cacheResult = queries.getAllPurchases(userHash = hashName).executeAsList()
            // emit List<SnftrIDMDto> from cache
            // Must manually map this since idawnPurchase_Entity object is generated by SQL Delight
            val list: ArrayList<SnftrIDPDto> = ArrayList()
            for(entity in cacheResult) {
                list.add(
                    SnftrIDPDto(
                        hashName = entity.userHash,
                        productId = entity.productId,
                        currency = entity.currency,
                        price = entity.price,
                        thymestamp = entity.thymestamp,
                        expiry = entity.expiry
                    )
                )
            }
            println("$TAG Success! fetchCachedIDAWNPurchases(userUid: userUid): emitting ${list.size}")
            emit(DataState.success(list))
        } catch (e: Exception) {
            emit(DataState.error<List<SnftrIDPDto>>(e.message ?: "Unknown Error - comments null"))
        }
    }.snftrFlow()


//    fun fetchOverCache(hashName: String, time: Double): Boolean {
//        val latestServerTime = time.toLong()
//        val latestLocalTime = snftrDatabase.iDAWNPurchasesQueries
//            .getNewest(userHash = hashName)
//            .executeAsOneOrNull()
//            ?.thymestamp ?: 1
//        val fetchOverCache =
//            (latestServerTime > latestLocalTime
//                    && latestServerTime > (latestLocalTime))
//                    || (latestServerTime == 0L
//                    && latestLocalTime == 1L)
//        println("$TAG fetchOverCache(server: $latestServerTime " +
//                "local: $latestLocalTime) -> $fetchOverCache")
//        return fetchOverCache
//    }
//
//    fun mostRecentIDMsgTime(hashName: String): Long {
//        val queries = snftrDatabase.iDAWNPurchasesQueries
//        val latestLocalTime = (queries
//            .getNewest(userHash = hashName)
//            .executeAsOneOrNull()?.thymestamp ?: -1)
//        println("$TAG mostRecentIDPTime(): $latestLocalTime")
//        return latestLocalTime
//    }

    companion object {
        const val TAG = "RestoreIDPurchases"
    }
}