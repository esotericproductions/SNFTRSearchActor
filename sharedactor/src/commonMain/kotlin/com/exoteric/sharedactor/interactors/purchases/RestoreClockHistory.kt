package com.exoteric.sharedactor.interactors.purchases

import com.exoteric.sharedactor.datasource.dtos.ClockHistoryDto
import com.exoteric.sharedactor.domain.data.DataState
import com.exoteric.sharedactor.domain.util.SnftrFlow
import com.exoteric.sharedactor.domain.util.snftrFlow
import com.exoteric.sharedactor.interactors.flowers.CLockEventHistoryCacheFlower
import com.exoteric.sharedactor.interactors.user.parseProfilesBlobBlocked
import com.exoteric.snftrdblib.cached.SnftrDatabase
import kotlinx.coroutines.flow.flow


class RestoreClockEventHistory(private val snftrDatabase: SnftrDatabase) : CLockEventHistoryCacheFlower {
    @Throws(Exception::class)
    override fun fetchCachedClockHistory(threadUuid: String, uid: String):
            SnftrFlow<DataState<List<ClockHistoryDto>>> = flow {
        try {
            emit(DataState.loading())
            val queries = snftrDatabase.clockEventHistoryQueries
            val cacheResult =
                queries.getAllClockHistory(threadUuid = threadUuid).executeAsList()
            // emit List<ClockHistoryDto> from cache
            // Must manually map this since clockHistory_Entity object is generated by SQL Delight
            val list: ArrayList<ClockHistoryDto> = ArrayList()
            for(entity in cacheResult) {
                val user = snftrDatabase.snftrUsersQueries.searchUsersByUid(uid).executeAsOneOrNull()
                val blocked = if(user == null) false else parseProfilesBlobBlocked(user.profilesBlob)?.map { it.uid }?.contains(entity.uid) ?: false
                list.add(
                    ClockHistoryDto(
                        uuid = entity.uuid,
                        uid = uid,
                        name = entity.name,
                        username = entity.username,
                        profilePic = entity.profilePic,
                        status = entity.status,
                        blocked = blocked,
                        thymestamp = entity.thymestamp
                    )
                )
            }
            println("$TAG Success! fetchCachedClockHistory(): emitting ${list.size}")
            emit(DataState.success(list))
        } catch (e: Exception) {
            emit(DataState.error<List<ClockHistoryDto>>(e.message ?: "Unknown Error - comments null"))
        }
    }.snftrFlow()


    fun fetchOverCache(uid: String, threadUuid: String, time: Double): Boolean {
        val latestServerTime = time.toLong()
        val latestLocalTime = snftrDatabase.clockEventHistoryQueries
            .getNewest(threadUuid = threadUuid)
            .executeAsOneOrNull()
            ?.thymestamp ?: 1
        val fetchOverCache =
            (latestServerTime > latestLocalTime
                    && latestServerTime > (latestLocalTime))
                    || (latestServerTime == 0L
                    && latestLocalTime == 1L)
        println("$TAG fetchOverCache(server: $latestServerTime " +
                "local: $latestLocalTime) -> $fetchOverCache")
        return fetchOverCache
    }

    fun mostRecentHistoryTime(uid: String, threadUuid: String,): Long {
        val queries = snftrDatabase.clockEventHistoryQueries
        val latestLocalTime = (queries
            .getNewest(threadUuid = threadUuid)
            .executeAsOneOrNull()?.thymestamp ?: -1)
        println("$TAG mostRecentIDPTime(): $latestLocalTime")
        return latestLocalTime
    }

    companion object {
        const val TAG = "RestoreClockHist"
    }
}