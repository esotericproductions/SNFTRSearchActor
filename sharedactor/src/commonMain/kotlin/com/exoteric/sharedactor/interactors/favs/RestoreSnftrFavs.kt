package com.exoteric.sharedactor.interactors.favs

import com.exoteric.sharedactor.datasource.dtos.FavsDto
import com.exoteric.sharedactor.domain.data.DataState
import com.exoteric.sharedactor.domain.util.SnftrFlow
import com.exoteric.sharedactor.domain.util.snftrFlow
import com.exoteric.sharedactor.interactors.chat.threads.getCachedUserProfilePic
import com.exoteric.sharedactor.interactors.flowers.SnftrFavsCacheFlower
import com.exoteric.snftrdblib.cached.SnftrDatabase
import com.exoteric.snftrsearchlibr.ITEMS_PER_PG_FVRTS
import kotlinx.coroutines.flow.flow

class RestoreSnftrFavs(private val snftrDatabase: SnftrDatabase): SnftrFavsCacheFlower {
    @Throws(Exception::class)
    override fun fetchCachedFavsFromDb(uid: String,
                                       page: Int):
            SnftrFlow<DataState<List<FavsDto>>> = flow {
        try {
            emit(DataState.loading())

//            if (!Platform().isAndroid()) delay(500)
            // query the cache
            val queries = snftrDatabase.snftrFavoritesQueries
            val cacheResult = queries.restoreAllFvrtsForPageByUid(
                userid = uid,
                offset = ((page - 1) * ITEMS_PER_PG_FVRTS).toLong(),
                limit = ITEMS_PER_PG_FVRTS.toLong()
            ).executeAsList()
            println("$TAG --> fetchCachedFavsFrom: " + cacheResult.size)

            // emit List<SnftrFavsDto> from cache
            // Must manually map this since favorite_Entity object is generated by SQL Delight
            val list: ArrayList<FavsDto> = ArrayList()
            for(entity in cacheResult) {
                list.add(
                    FavsDto(
                        id = entity.id.toInt(),
                        uid = entity.uuid,
                        cmmtUuid = entity.cmmtUuid,
                        title = entity.title,
                        posterUid = entity.userid,
                        provider = entity.provider,
                        creator = entity.creator,
                        creatorProfilePic = getCachedUserProfilePic(uid, snftrDatabase) ?: entity.creatorProfilePic,
                        sourceUrlDetail = entity.source_url_detail,
                        sourceUrlThumb = entity.source_url_thumb,
                        sourceUrlOwner = entity.source_url_owner,
                        randomSeed = entity.random_seed.toInt(),
                        thymestamp = entity.thymeStamp,
                        page = 0
                    )
                )
            }
            emit(DataState.success(list))
        } catch (e: Exception) { emit(
            DataState.error<List<FavsDto>>(
            e.message?: "RestoreFavs: Unknown Error")) }
    }.snftrFlow()

    fun newestCachedTimestamp(uid: String): Long {
        val newest = snftrDatabase.snftrFavoritesQueries
            .getNewest(userid = uid)
            .executeAsOneOrNull()?.thymeStamp ?: 0
        println("$TAG: newestCachedTimestamp(uid): $newest")
        return newest
    }

    fun oldestCachedTimestamp(uid: String): Long {
        val oldest = snftrDatabase.snftrFavoritesQueries
            .getOldest(userid = uid)
            .executeAsOneOrNull()?.thymeStamp ?: 0
        println("$TAG: oldestCachedTimestamp(uid): $oldest")
        return oldest
    }

    /**
     * how many items are needed in order to fill up a page:
     *
     * if there are 82 items in the cache, then there are 38 needed to
     * fill up a new page if ITEMS_PER_PG_FVRTS == 60
     *
     * @return number of items to add to a new page to == ITEMS_PER_PG_FVRTS
     */
    fun numberOfItemsToFetchForNewPage(uid: String): Int {
        val howMany = ITEMS_PER_PG_FVRTS - (getItemCount(uid = uid) % ITEMS_PER_PG_FVRTS)
        println("$TAG: numberOfItemsToFetchForNewPage(uid: uid): $howMany")
        return howMany
    }

    /**
     * @returns true if:
     * rows in the db >= ITEMS_PER_PG_FVRTS: enough to fill an entire new page
     */
    fun hasCachedForPage(uid: String?, page: Int): Boolean {
        if (uid == null)  return false
        val itemsInCache = getItemCount(uid = uid)
        val itemsInPagesThusFar = ((page - 1) * ITEMS_PER_PG_FVRTS)
        val itemsRemaining = itemsInCache - itemsInPagesThusFar
        // enough to fill a whole new page?
        val goToNextPageWithCache = itemsRemaining >= ITEMS_PER_PG_FVRTS
        println("$TAG: hasCached(uuid: uid, pg: $page): "  +
                "\n $itemsInPagesThusFar items in pages thus far " +
                "\n $itemsRemaining remaining items " +
                "\n $itemsInCache items in total: goWithCache -> $goToNextPageWithCache")
        return goToNextPageWithCache
    }

    fun totalPagesInCache(uid: String): Int {
        return countNumberOfPages(
            numberOfObjects = getItemCount(uid = uid),
            pageSize = ITEMS_PER_PG_FVRTS
        )
    }

    private fun countNumberOfPages(numberOfObjects: Int, pageSize: Int): Int {
        return (numberOfObjects) / pageSize +
                if (numberOfObjects % pageSize == 0
                    || numberOfObjects < pageSize) 0 else 1
    }

    fun getItemCount(uid: String): Int {
        return snftrDatabase.snftrFavoritesQueries
            .selectCountAllForUserid(userid = uid)
            .executeAsOneOrNull()?.toInt() ?: -1
    }

    private fun mostRecentFavsTime(uid: String): Long {
        val queries = snftrDatabase.snftrUsersQueries
        val latestLocalTime = (queries
            .searchUsersByUid(uid = uid)
            .executeAsOneOrNull()?.favsTime ?: 1) / 1000
        println("$TAG: mostRecentFvrtsTime(): $latestLocalTime")
        return latestLocalTime
    }

    fun fetchOverCache(uid: String): Boolean {
        val latestServerTime = mostRecentFavsTime(uid = uid)
        val latestLocalTime = snftrDatabase.snftrFavoritesQueries
            .getNewest(userid = uid)
            .executeAsOneOrNull()
            ?.thymeStamp ?: 1
        val fetchOverCache =
            (latestServerTime > latestLocalTime) || (latestLocalTime == 1L)
        println("$TAG: fetchOverCache(server: $latestServerTime " +
                "local: $latestLocalTime) -> $fetchOverCache")
        return fetchOverCache
    }

    fun deleteFavByUid(uuid: String, myCallback: (deleted: Boolean) -> Unit) {
        val query = snftrDatabase.snftrFavoritesQueries
        query.deleteFavorite(uuid = uuid)
        val check = query.getFavoriteByUuid(uuid = uuid).executeAsOneOrNull()
        myCallback(check == null)
    }

    fun checkForFavByUidAndUrlThumb(userUid: String,
                                    urlThumb: String,
                                    myCallback: (fav: FavsDto?) -> Unit) {
        val query = snftrDatabase.snftrFavoritesQueries
        val entity = query
            .getFavByUserUidAndUrlThumb(
                userUid = userUid,
                urlThumb = urlThumb)
            .executeAsOneOrNull()
        if (entity != null) {
            myCallback(
                FavsDto(
                    id = entity.id.toInt(),
                    uid = entity.uuid,
                    cmmtUuid = entity.cmmtUuid,
                    title = entity.title,
                    posterUid = entity.userid,
                    provider = entity.provider,
                    creator = entity.creator,
                    creatorProfilePic = entity.creatorProfilePic,
                    sourceUrlDetail = entity.source_url_detail,
                    sourceUrlThumb = entity.source_url_thumb,
                    sourceUrlOwner = entity.source_url_owner,
                    randomSeed = entity.random_seed.toInt(),
                    thymestamp = entity.thymeStamp,
                    page = 0
                )
            )
        } else myCallback(null)
    }

    fun setCurrentPgNumber(page: Int, caller: String) {
        val queries = snftrDatabase.snftrSettingsQueries
        val mostRecentPg = queries
            .getSettingByKey(key = MOST_RECENT_PG_FAVS + caller)
            .executeAsOneOrNull()
        if (mostRecentPg == null) {
            println("$TAG setCurrentPgNumber():" +
                    " mostRecentPg == null, current: $page")
            queries.insertSettings(
                category = CAT_PG_FAVS + caller,
                key = MOST_RECENT_PG_FAVS + caller,
                value_ = page.toString(),
                thymestamp = 0
            )
        } else if (mostRecentPg.value_ != page.toString()){
            println("$TAG setCurrentPgNumber():" +
                    " stale: ${mostRecentPg.value_}, current: $page")
            queries.updateSettings(
                key = MOST_RECENT_PG_FAVS + caller,
                value_ = page.toString())
        }
    }

    fun mostRecentPgNumber(caller: String): Int? {
        val queries = snftrDatabase.snftrSettingsQueries
        val mostRecentPg = queries
            .getSettingByKey(key = MOST_RECENT_PG_FAVS + caller)
            .executeAsOneOrNull()
        println("$TAG pageNumber(): ${mostRecentPg?.value_ ?: 1}")
        return mostRecentPg?.value_?.toInt()
    }

    companion object {
        const val TAG = "RestoreSnftrFavs"
        private const val MOST_RECENT_PG_FAVS = "most_recent_pg_favs"
        const val CAT_PG_FAVS = "category_page_favs"
    }
}